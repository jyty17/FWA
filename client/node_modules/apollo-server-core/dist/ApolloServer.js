"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_tools_1 = require("graphql-tools");
const graphql_1 = require("graphql");
const apollo_tracing_1 = require("apollo-tracing");
const apollo_cache_control_1 = require("apollo-cache-control");
const apollo_engine_reporting_1 = require("apollo-engine-reporting");
const subscriptions_transport_ws_1 = require("subscriptions-transport-ws");
const Keyv = require("keyv");
const QuickLru = require("quick-lru");
const errors_1 = require("./errors");
const NoIntrospection = (context) => ({
    Field(node) {
        if (node.name.value === '__schema' || node.name.value === '__type') {
            context.reportError(new graphql_1.GraphQLError('GraphQL introspection is not allowed by Apollo Server, but the query contained __schema or __type. To enable introspection, pass introspection: true to ApolloServer in production', [node]));
        }
    },
});
class ApolloServerBase {
    constructor(config) {
        this.graphqlPath = '/graphql';
        const { context, resolvers, schema, schemaDirectives, typeDefs, introspection, mocks, extensions, engine } = config, requestOptions = __rest(config, ["context", "resolvers", "schema", "schemaDirectives", "typeDefs", "introspection", "mocks", "extensions", "engine"]);
        const env = process.env.NODE_ENV;
        const isDev = env !== 'production' && env !== 'test';
        if (typeof introspection === 'boolean')
            this.disableTools = !introspection;
        else
            this.disableTools = !isDev;
        if (this.disableTools) {
            const noIntro = [NoIntrospection];
            requestOptions.validationRules = requestOptions.validationRules
                ? requestOptions.validationRules.concat(noIntro)
                : noIntro;
        }
        if (requestOptions.persistedQueries !== false) {
            if (!requestOptions.persistedQueries) {
                const lru = new QuickLru({ maxSize: 300 });
                requestOptions.persistedQueries = {
                    cache: new Keyv({ store: lru }),
                };
            }
        }
        else {
            delete requestOptions.persistedQueries;
        }
        this.requestOptions = requestOptions;
        this.context = context;
        if (typeof typeDefs === 'string' ||
            (Array.isArray(typeDefs) && typeDefs.find(d => typeof d === 'string'))) {
            const startSchema = (typeof typeDefs === 'string' &&
                typeDefs.substring(0, 200)) ||
                (Array.isArray(typeDefs) &&
                    typeDefs.find(d => typeof d === 'string').substring(0, 200));
            throw new Error(`typeDefs must be tagged with the gql exported from apollo-server:

const { gql } = require('apollo-server');

const typeDefs = gql\`${startSchema}\`
`);
        }
        const enhancedTypeDefs = Array.isArray(typeDefs)
            ? typeDefs.map(graphql_1.print)
            : [graphql_1.print(typeDefs)];
        enhancedTypeDefs.push(`scalar Upload`);
        this.schema = schema
            ? schema
            : graphql_tools_1.makeExecutableSchema({
                typeDefs: enhancedTypeDefs.join('\n'),
                schemaDirectives,
                resolvers,
            });
        if (mocks) {
            graphql_tools_1.addMockFunctionsToSchema({
                schema: this.schema,
                preserveResolvers: true,
                mocks: typeof mocks === 'boolean' ? {} : mocks,
            });
        }
        this.extensions = [];
        if (engine || (engine !== false && process.env.ENGINE_API_KEY)) {
            this.engineReportingAgent = new apollo_engine_reporting_1.EngineReportingAgent(engine === true ? {} : engine);
            this.extensions.push(() => this.engineReportingAgent.newExtension());
        }
        if (extensions) {
            this.extensions = [...this.extensions, ...extensions];
        }
    }
    use({ getHttp, path }) {
        this.getHttp = getHttp;
        this.graphqlPath = path;
    }
    enhanceSchema(schema) {
        this.schema = graphql_tools_1.mergeSchemas({
            schemas: [
                this.schema,
                'typeDefs' in schema ? schema['typeDefs'] : schema,
            ],
            resolvers: 'resolvers' in schema ? [, schema['resolvers']] : {},
        });
    }
    listen(opts = {}) {
        this.http = this.getHttp();
        const options = Object.assign({}, opts, { http: Object.assign({ port: process.env.PORT || 4000 }, opts.http) });
        if (opts.subscriptions !== false) {
            let config;
            if (opts.subscriptions === true ||
                typeof opts.subscriptions === 'undefined') {
                config = {
                    path: this.graphqlPath,
                };
            }
            else if (typeof opts.subscriptions === 'string') {
                config = { path: opts.subscriptions };
            }
            else {
                config = Object.assign({ path: this.graphqlPath }, opts.subscriptions);
            }
            this.subscriptionsPath = config.path;
            this.subscriptionServer = this.createSubscriptionServer(this.http, config);
        }
        if (opts.engineProxy || opts.engineInRequestPath)
            this.createEngine(opts);
        return new Promise((resolve, reject) => {
            if (this.engineProxy) {
                this.engineProxy.listen({
                    graphqlPaths: [this.graphqlPath],
                    port: options.http.port,
                    httpServer: this.http,
                    launcherOptions: options.engineLauncherOptions,
                }, () => {
                    this.engineProxy.engineListeningAddress.url = require('url').resolve(this.engineProxy.engineListeningAddress.url, this.graphqlPath);
                    resolve(this.engineProxy.engineListeningAddress);
                });
                this.engineProxy.on('error', reject);
                return;
            }
            function listenCallback() {
                const listeningAddress = this.http.address();
                let hostForUrl = listeningAddress.address;
                if (listeningAddress.address === '' ||
                    listeningAddress.address === '::')
                    hostForUrl = 'localhost';
                listeningAddress.url = require('url').format({
                    protocol: 'http',
                    hostname: hostForUrl,
                    port: listeningAddress.port,
                    pathname: this.graphqlPath,
                });
                resolve(listeningAddress);
            }
            if (options.http.handle) {
                this.http.listen(options.http.handle, options.http.backlog, listenCallback.bind(this));
            }
            else {
                this.http.listen(options.http, listenCallback.bind(this));
            }
        });
    }
    async stop() {
        if (this.engineProxy)
            await this.engineProxy.stop();
        if (this.subscriptionServer)
            await this.subscriptionServer.close();
        if (this.http)
            await new Promise(s => this.http.close(s));
        if (this.engineReportingAgent) {
            this.engineReportingAgent.stop();
            await this.engineReportingAgent.sendReport();
        }
    }
    createSubscriptionServer(server, config) {
        const { onDisconnect, onConnect, keepAlive, path } = config;
        return subscriptions_transport_ws_1.SubscriptionServer.create({
            schema: this.schema,
            execute: graphql_1.execute,
            subscribe: graphql_1.subscribe,
            onConnect: onConnect
                ? onConnect
                : (connectionParams) => (Object.assign({}, connectionParams)),
            onDisconnect: onDisconnect,
            onOperation: async (_, connection) => {
                connection.formatResponse = (value) => (Object.assign({}, value, { errors: value.errors &&
                        errors_1.formatApolloErrors([...value.errors], {
                            formatter: this.requestOptions.formatError,
                            debug: this.requestOptions.debug,
                            logFunction: this.requestOptions.logFunction,
                        }) }));
                let context = this.context ? this.context : { connection };
                try {
                    context =
                        typeof this.context === 'function'
                            ? await this.context({ connection })
                            : context;
                }
                catch (e) {
                    throw errors_1.formatApolloErrors([e], {
                        formatter: this.requestOptions.formatError,
                        debug: this.requestOptions.debug,
                        logFunction: this.requestOptions.logFunction,
                    })[0];
                }
                return Object.assign({}, connection, { context });
            },
            keepAlive,
        }, {
            server,
            path,
        });
    }
    createEngine({ engineInRequestPath, engineProxy }) {
        const { ENGINE_API_KEY, ENGINE_CONFIG } = process.env;
        if (engineProxy === false && (ENGINE_API_KEY || ENGINE_CONFIG)) {
            console.warn('engine is set to false when creating ApolloServer but either ENGINE_CONFIG or ENGINE_API_KEY was found in the environment');
        }
        let ApolloEngine;
        if (engineProxy) {
            try {
                ApolloEngine = require('apollo-engine').ApolloEngine;
            }
            catch (e) {
                console.warn(`ApolloServer was unable to load Apollo Engine yet engine was configured in the options when creating this ApolloServer? To fix this, run the following command:

  npm install apollo-engine --save
`);
            }
            this.engineProxy = new ApolloEngine(typeof engineProxy === 'boolean' ? undefined : engineProxy);
        }
        if (this.engineProxy || engineInRequestPath) {
            this.extensions.push(() => new apollo_tracing_1.TracingExtension());
            this.extensions.push(() => new apollo_cache_control_1.CacheControlExtension());
        }
    }
    async graphQLServerOptionsForRequest(request) {
        let context = this.context ? this.context : { request };
        try {
            context =
                typeof this.context === 'function'
                    ? await this.context({
                        req: request,
                    })
                    : context;
        }
        catch (error) {
            context = () => {
                throw error;
            };
        }
        return Object.assign({ schema: this.schema, extensions: this.extensions, context, logFunction: this.requestOptions.logFunction, persistedQueries: this.requestOptions
                .persistedQueries, fieldResolver: this.requestOptions.fieldResolver }, this.requestOptions);
    }
}
exports.ApolloServerBase = ApolloServerBase;
//# sourceMappingURL=ApolloServer.js.map