"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var graphql_extensions_1 = require("graphql-extensions");
var apollo_tracing_1 = require("apollo-tracing");
var apollo_cache_control_1 = require("apollo-cache-control");
var errors_1 = require("./errors");
var logging_1 = require("./logging");
function isQueryOperation(query, operationName) {
    var operationAST = graphql_1.getOperationAST(query, operationName);
    return operationAST.operation === 'query';
}
function runQuery(options) {
    return Promise.resolve().then(function () { return doRunQuery(options); });
}
exports.runQuery = runQuery;
function doRunQuery(options) {
    if (options.queryString && options.parsedQuery) {
        throw new Error('Only supply one of queryString and parsedQuery');
    }
    if (!(options.queryString || options.parsedQuery)) {
        throw new Error('Must supply one of queryString and parsedQuery');
    }
    var logFunction = options.logFunction ||
        function () {
            return null;
        };
    var debugDefault = process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test';
    var debug = options.debug !== undefined ? options.debug : debugDefault;
    logFunction({ action: logging_1.LogAction.request, step: logging_1.LogStep.start });
    var context = options.context || {};
    var extensions = options.extensions ? options.extensions.map(function (f) { return f(); }) : [];
    if (options.tracing) {
        extensions.push(new apollo_tracing_1.TracingExtension());
    }
    if (options.cacheControl === true) {
        extensions.push(new apollo_cache_control_1.CacheControlExtension());
    }
    else if (options.cacheControl) {
        extensions.push(new apollo_cache_control_1.CacheControlExtension(options.cacheControl));
    }
    var extensionStack = new graphql_extensions_1.GraphQLExtensionStack(extensions);
    if (extensions.length > 0) {
        context._extensionStack = extensionStack;
        graphql_extensions_1.enableGraphQLExtensions(options.schema);
    }
    var requestDidEnd = extensionStack.requestDidStart({
        request: options.request,
    });
    return Promise.resolve()
        .then(function () {
        var loggedQuery = options.queryString || graphql_1.print(options.parsedQuery);
        logFunction({
            action: logging_1.LogAction.request,
            step: logging_1.LogStep.status,
            key: 'query',
            data: loggedQuery,
        });
        logFunction({
            action: logging_1.LogAction.request,
            step: logging_1.LogStep.status,
            key: 'variables',
            data: options.variables,
        });
        logFunction({
            action: logging_1.LogAction.request,
            step: logging_1.LogStep.status,
            key: 'operationName',
            data: options.operationName,
        });
        var documentAST;
        if (options.parsedQuery) {
            documentAST = options.parsedQuery;
        }
        else if (!options.queryString) {
            throw new Error('Must supply one of queryString and parsedQuery');
        }
        else {
            logFunction({ action: logging_1.LogAction.parse, step: logging_1.LogStep.start });
            var parsingDidEnd = extensionStack.parsingDidStart({
                queryString: options.queryString,
            });
            var graphqlParseErrors = void 0;
            try {
                documentAST = graphql_1.parse(options.queryString);
            }
            catch (syntaxError) {
                graphqlParseErrors = errors_1.formatApolloErrors([
                    errors_1.fromGraphQLError(syntaxError, {
                        errorClass: errors_1.SyntaxError,
                    }),
                ], {
                    formatter: options.formatError,
                    debug: debug,
                });
            }
            finally {
                parsingDidEnd.apply(void 0, (graphqlParseErrors || []));
                logFunction({ action: logging_1.LogAction.parse, step: logging_1.LogStep.end });
                if (graphqlParseErrors) {
                    return Promise.resolve({ errors: graphqlParseErrors });
                }
            }
        }
        if (options.nonQueryError &&
            !isQueryOperation(documentAST, options.operationName)) {
            throw options.nonQueryError;
        }
        var rules = graphql_1.specifiedRules;
        if (options.validationRules) {
            rules = rules.concat(options.validationRules);
        }
        logFunction({ action: logging_1.LogAction.validation, step: logging_1.LogStep.start });
        var validationDidEnd = extensionStack.validationDidStart();
        var validationErrors;
        try {
            validationErrors = graphql_1.validate(options.schema, documentAST, rules);
        }
        catch (validationThrewError) {
            validationErrors = [validationThrewError];
        }
        finally {
            try {
                if (validationErrors) {
                    validationErrors = errors_1.formatApolloErrors(validationErrors.map(function (err) {
                        return errors_1.fromGraphQLError(err, { errorClass: errors_1.ValidationError });
                    }), {
                        formatter: options.formatError,
                        logFunction: logFunction,
                        debug: debug,
                    });
                }
            }
            finally {
                validationDidEnd.apply(void 0, (validationErrors || []));
                logFunction({ action: logging_1.LogAction.validation, step: logging_1.LogStep.end });
                if (validationErrors && validationErrors.length) {
                    return Promise.resolve({
                        errors: validationErrors,
                    });
                }
            }
        }
        var executionArgs = {
            schema: options.schema,
            document: documentAST,
            rootValue: options.rootValue,
            contextValue: context,
            variableValues: options.variables,
            operationName: options.operationName,
            fieldResolver: options.fieldResolver,
        };
        logFunction({ action: logging_1.LogAction.execute, step: logging_1.LogStep.start });
        var executionDidEnd = extensionStack.executionDidStart({
            executionArgs: executionArgs,
        });
        return Promise.resolve()
            .then(function () { return graphql_1.execute(executionArgs); })
            .catch(function (executionError) {
            return {
                errors: [errors_1.fromGraphQLError(executionError)],
            };
        })
            .then(function (result) {
            var response = {
                data: result.data,
            };
            if (result.errors) {
                response.errors = errors_1.formatApolloErrors(result.errors.slice(), {
                    formatter: options.formatError,
                    logFunction: logFunction,
                    debug: debug,
                });
            }
            executionDidEnd.apply(void 0, result.errors);
            logFunction({ action: logging_1.LogAction.execute, step: logging_1.LogStep.end });
            var formattedExtensions = extensionStack.format();
            if (Object.keys(formattedExtensions).length > 0) {
                response.extensions = formattedExtensions;
            }
            if (options.formatResponse) {
                response = options.formatResponse(response, options);
            }
            return response;
        });
    })
        .catch(function (err) {
        requestDidEnd(err);
        logFunction({ action: logging_1.LogAction.request, step: logging_1.LogStep.end });
        throw err;
    })
        .then(function (graphqlResponse) {
        extensionStack.willSendResponse({ graphqlResponse: graphqlResponse });
        requestDidEnd();
        logFunction({
            action: logging_1.LogAction.request,
            step: logging_1.LogStep.end,
            key: 'response',
            data: graphqlResponse,
        });
        return graphqlResponse;
    });
}
//# sourceMappingURL=flycheck_runQuery.js.map