"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const _256_1 = __importDefault(require("hash.js/lib/hash/sha/256"));
const runQuery_1 = require("./runQuery");
const graphqlOptions_1 = require("./graphqlOptions");
const errors_1 = require("./errors");
const logging_1 = require("./logging");
function prettyJSONStringify(toStringfy) {
    return JSON.stringify(toStringfy) + '\n';
}
class HttpQueryError extends Error {
    constructor(statusCode, message, isGraphQLError = false, headers) {
        super(message);
        this.name = 'HttpQueryError';
        this.statusCode = statusCode;
        this.isGraphQLError = isGraphQLError;
        this.headers = headers;
    }
}
exports.HttpQueryError = HttpQueryError;
function throwHttpGraphQLError(statusCode, errors, optionsObject) {
    throw new HttpQueryError(statusCode, prettyJSONStringify({
        errors: errors_1.formatApolloErrors(errors, {
            debug: optionsObject.debug,
            formatter: optionsObject.formatError,
            logFunction: optionsObject.logFunction,
        }),
    }), true, {
        'Content-Type': 'application/json',
    });
}
async function runHttpQuery(handlerArguments, request) {
    let isGetRequest = false;
    let optionsObject;
    const debugDefault = process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test';
    try {
        optionsObject = await graphqlOptions_1.resolveGraphqlOptions(request.options, ...handlerArguments);
    }
    catch (e) {
        e.message = `Invalid options provided to ApolloServer: ${e.message}`;
        if (!debugDefault) {
            e.warning = `To remove the stacktrace, set the NODE_ENV environment variable to production if the options creation can fail`;
        }
        throwHttpGraphQLError(500, [e], { debug: debugDefault });
    }
    if (optionsObject.debug === undefined) {
        optionsObject.debug = debugDefault;
    }
    let requestPayload;
    switch (request.method) {
        case 'POST':
            if (!request.query || Object.keys(request.query).length === 0) {
                throw new HttpQueryError(500, 'POST body missing. Did you forget use body-parser middleware?');
            }
            requestPayload = request.query;
            break;
        case 'GET':
            if (!request.query || Object.keys(request.query).length === 0) {
                throw new HttpQueryError(400, 'GET query missing.');
            }
            isGetRequest = true;
            requestPayload = request.query;
            break;
        default:
            throw new HttpQueryError(405, 'Apollo Server supports only GET/POST requests.', false, {
                Allow: 'GET, POST',
            });
    }
    let isBatch = true;
    if (!Array.isArray(requestPayload)) {
        isBatch = false;
        requestPayload = [requestPayload];
    }
    const requests = requestPayload.map(async (requestParams) => {
        try {
            let queryString = requestParams.query;
            let extensions = requestParams.extensions;
            if (isGetRequest && extensions) {
                try {
                    extensions = JSON.parse(extensions);
                }
                catch (error) {
                    throw new HttpQueryError(400, 'Extensions are invalid JSON.');
                }
            }
            if (extensions && extensions.persistedQuery) {
                if (!optionsObject.persistedQueries ||
                    !optionsObject.persistedQueries.cache) {
                    throwHttpGraphQLError(200, [new errors_1.PersistedQueryNotSupportedError()], optionsObject);
                }
                else if (extensions.persistedQuery.version !== 1) {
                    throw new HttpQueryError(400, 'Unsupported persisted query version');
                }
                const sha = extensions.persistedQuery.sha256Hash;
                if (queryString === undefined) {
                    queryString = await optionsObject.persistedQueries.cache.get(sha);
                    if (!queryString) {
                        throwHttpGraphQLError(200, [new errors_1.PersistedQueryNotFoundError()], optionsObject);
                    }
                }
                else {
                    const calculatedSha = _256_1.default()
                        .update(queryString)
                        .digest('hex');
                    if (sha !== calculatedSha) {
                        throw new HttpQueryError(400, 'provided sha does not match query');
                    }
                    Promise.resolve()
                        .then(() => {
                        return optionsObject.persistedQueries.cache.set(sha, queryString);
                    })
                        .catch(error => {
                        if (optionsObject.logFunction) {
                            optionsObject.logFunction({
                                action: logging_1.LogAction.setup,
                                step: logging_1.LogStep.status,
                                key: 'error',
                                data: error,
                            });
                        }
                        else {
                            console.warn(error);
                        }
                    });
                }
            }
            if (queryString && typeof queryString !== 'string') {
                if (queryString && queryString.kind === 'Document') {
                    throw new HttpQueryError(400, "GraphQL queries must be strings. It looks like you're sending the " +
                        'internal graphql-js representation of a parsed query in your ' +
                        'request instead of a request in the GraphQL query language. You ' +
                        'can convert an AST to a string using the `print` function from ' +
                        '`graphql`, or use a client like `apollo-client` which converts ' +
                        'the internal representation to a string for you.');
                }
                throw new HttpQueryError(400, 'GraphQL queries must be strings.');
            }
            let nonQueryError;
            if (isGetRequest) {
                nonQueryError = new HttpQueryError(405, `GET supports only query operation`, false, {
                    Allow: 'POST',
                });
            }
            const operationName = requestParams.operationName;
            let variables = requestParams.variables;
            if (typeof variables === 'string') {
                try {
                    variables = JSON.parse(variables);
                }
                catch (error) {
                    throw new HttpQueryError(400, 'Variables are invalid JSON.');
                }
            }
            let context = optionsObject.context;
            if (!context) {
                context = {};
            }
            else if (typeof context === 'function') {
                try {
                    context = await context();
                }
                catch (e) {
                    e.message = `Context creation failed: ${e.message}`;
                    throwHttpGraphQLError(500, [e], optionsObject);
                }
            }
            else if (isBatch) {
                context = Object.assign(Object.create(Object.getPrototypeOf(context)), context);
            }
            let params = {
                schema: optionsObject.schema,
                queryString,
                nonQueryError,
                variables: variables,
                context,
                rootValue: optionsObject.rootValue,
                operationName: operationName,
                logFunction: optionsObject.logFunction,
                validationRules: optionsObject.validationRules,
                formatError: optionsObject.formatError,
                formatResponse: optionsObject.formatResponse,
                fieldResolver: optionsObject.fieldResolver,
                debug: optionsObject.debug,
                tracing: optionsObject.tracing,
                cacheControl: optionsObject.cacheControl,
                request: request.request,
                extensions: optionsObject.extensions,
            };
            if (optionsObject.formatParams) {
                params = optionsObject.formatParams(params);
            }
            if (!params.queryString && !params.parsedQuery) {
                throw new HttpQueryError(400, 'Must provide query string.');
            }
            return runQuery_1.runQuery(params);
        }
        catch (e) {
            if (e.name === 'HttpQueryError') {
                throw e;
            }
            return {
                errors: errors_1.formatApolloErrors([e], {
                    formatter: optionsObject.formatError,
                    debug: optionsObject.debug,
                    logFunction: optionsObject.logFunction,
                }),
            };
        }
    });
    const responses = await Promise.all(requests);
    if (!isBatch) {
        const gqlResponse = responses[0];
        if (gqlResponse.errors && typeof gqlResponse.data === 'undefined') {
            throw new HttpQueryError(400, prettyJSONStringify(gqlResponse), true, {
                'Content-Type': 'application/json',
            });
        }
        return prettyJSONStringify(gqlResponse);
    }
    return prettyJSONStringify(responses);
}
exports.runHttpQuery = runHttpQuery;
//# sourceMappingURL=runHttpQuery.js.map